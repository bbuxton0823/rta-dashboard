// Dashboard-specific code for RTA Application Dashboard\n\n// These functions will be called from the main app.js file\n// This file contains dashboard-specific logic like KPI calculations\n\n// Initialize the dashboard\nfunction initDashboard() {\n    if (!app.data) return;\n    \n    // Set up dashboard-specific event listeners\n    setupDashboardEventListeners();\n}\n\n// Set up dashboard-specific event listeners\nfunction setupDashboardEventListeners() {\n    // Navigation pill events for showing/hiding dashboard sections\n    document.querySelectorAll('.nav-link').forEach(navLink => {\n        navLink.addEventListener('click', function(e) {\n            e.preventDefault();\n            \n            // Set active nav link\n            document.querySelectorAll('.nav-link').forEach(link => {\n                link.classList.remove('active');\n            });\n            this.classList.add('active');\n            \n            // Show corresponding section\n            const targetId = this.getAttribute('href').substring(1);\n            document.querySelectorAll('section').forEach(section => {\n                section.classList.add('d-none');\n            });\n            document.getElementById(targetId).classList.remove('d-none');\n        });\n    });\n}\n\n// Calculate key performance indicators\nfunction calculateKPIs(data) {\n    if (!data || data.length === 0) {\n        return {\n            totalApplications: 0,\n            approvalRate: 0,\n            avgProcessingDays: 0,\n            pendingInspections: 0\n        };\n    }\n    \n    // Total applications\n    const totalApplications = data.length;\n    \n    // Calculate approval rate\n    const approvedCount = data.filter(record => record['Date RTA Approved']).length;\n    const approvalRate = totalApplications > 0 ? Math.round((approvedCount / totalApplications) * 100) : 0;\n    \n    // Calculate average processing days\n    let totalDays = 0;\n    let countWithDays = 0;\n    \n    data.forEach(record => {\n        const receiveDate = new Date(record['Date RTA Received by HACSCM']);\n        let endDate;\n        \n        if (record['Date RTA Approved']) {\n            endDate = new Date(record['Date RTA Approved']);\n        } else if (record['RTA Denial Reason']) {\n            // Use the Date to Fiscal as end date for denied applications, if available\n            endDate = record['Date to Fiscal'] ? new Date(record['Date to Fiscal']) : null;\n        }\n        \n        if (receiveDate && endDate) {\n            const days = Math.round((endDate - receiveDate) / (1000 * 60 * 60 * 24));\n            if (days >= 0 && days < 1000) { // Sanity check to exclude outliers\n                totalDays += days;\n                countWithDays++;\n            }\n        }\n    });\n    \n    const avgProcessingDays = countWithDays > 0 ? Math.round(totalDays / countWithDays) : 0;\n    \n    // Calculate pending inspections\n    const pendingInspectionCount = data.filter(record => \n        record['Inspector'] && \n        !record['Date Inspected'] && \n        !record['Date RTA Approved'] && \n        !record['RTA Denial Reason']\n    ).length;\n    \n    return {\n        totalApplications,\n        approvalRate,\n        avgProcessingDays,\n        pendingInspectionCount\n    };\n}\n\n// Generate process metrics\nfunction calculateProcessMetrics(data) {\n    if (!data || data.length === 0) {\n        return {\n            receiptToAssignment: 0,\n            assignmentToInspection: 0,\n            inspectionToRentDetermination: 0,\n            determinationToApproval: 0\n        };\n    }\n    \n    // Filter out records with incomplete data or extreme outliers\n    const filteredData = data.filter(record => {\n        return record['Date RTA Received by HACSCM'] && \n               record['Date RTA Assigned to Inspector'] &&\n               new Date(record['Date RTA Assigned to Inspector']) >= new Date(record['Date RTA Received by HACSCM']);\n    });\n    \n    // Calculate average days from receipt to assignment\n    let receiptToAssignmentTotal = 0;\n    let receiptToAssignmentCount = 0;\n    \n    filteredData.forEach(record => {\n        const receiveDate = new Date(record['Date RTA Received by HACSCM']);\n        const assignDate = new Date(record['Date RTA Assigned to Inspector']);\n        \n        if (receiveDate && assignDate) {\n            const days = Math.round((assignDate - receiveDate) / (1000 * 60 * 60 * 24));\n            if (days >= 0 && days < 100) { // Exclude extreme outliers\n                receiptToAssignmentTotal += days;\n                receiptToAssignmentCount++;\n            }\n        }\n    });\n    \n    // Calculate average days from assignment to inspection\n    let assignmentToInspectionTotal = 0;\n    let assignmentToInspectionCount = 0;\n    \n    filteredData.forEach(record => {\n        const assignDate = new Date(record['Date RTA Assigned to Inspector']);\n        const inspectDate = new Date(record['Date Inspected']);\n        \n        if (assignDate && inspectDate && !isNaN(inspectDate.getTime())) {\n            const days = Math.round((inspectDate - assignDate) / (1000 * 60 * 60 * 24));\n            if (days >= 0 && days < 100) {\n                assignmentToInspectionTotal += days;\n                assignmentToInspectionCount++;\n            }\n        }\n    });\n    \n    // Calculate average days from inspection to rent determination\n    let inspectionToRentDeterminationTotal = 0;\n    let inspectionToRentDeterminationCount = 0;\n    \n    filteredData.forEach(record => {\n        const inspectDate = new Date(record['Date Inspected']);\n        const rentDate = new Date(record['Rent Reasonableness Date']);\n        \n        if (inspectDate && rentDate && !isNaN(inspectDate.getTime()) && !isNaN(rentDate.getTime())) {\n            const days = Math.round((rentDate - inspectDate) / (1000 * 60 * 60 * 24));\n            if (days >= 0 && days < 100) {\n                inspectionToRentDeterminationTotal += days;\n                inspectionToRentDeterminationCount++;\n            }\n        }\n    });\n    \n    // Calculate average days from rent determination to approval/denial\n    let determinationToApprovalTotal = 0;\n    let determinationToApprovalCount = 0;\n    \n    filteredData.forEach(record => {\n        const rentDate = new Date(record['Rent Reasonableness Date']);\n        let decisionDate;\n        \n        if (record['Date RTA Approved']) {\n            decisionDate = new Date(record['Date RTA Approved']);\n        } else if (record['RTA Denial Reason'] && record['Date to Fiscal']) {\n            decisionDate = new Date(record['Date to Fiscal']);\n        }\n        \n        if (rentDate && decisionDate && !isNaN(rentDate.getTime()) && !isNaN(decisionDate.getTime())) {\n            const days = Math.round((decisionDate - rentDate) / (1000 * 60 * 60 * 24));\n            if (days >= 0 && days < 100) {\n                determinationToApprovalTotal += days;\n                determinationToApprovalCount++;\n            }\n        }\n    });\n    \n    return {\n        receiptToAssignment: receiptToAssignmentCount > 0 ? (receiptToAssignmentTotal / receiptToAssignmentCount) : 0,\n        assignmentToInspection: assignmentToInspectionCount > 0 ? (assignmentToInspectionTotal / assignmentToInspectionCount) : 0,\n        inspectionToRentDetermination: inspectionToRentDeterminationCount > 0 ? (inspectionToRentDeterminationTotal / inspectionToRentDeterminationCount) : 0,\n        determinationToApproval: determinationToApprovalCount > 0 ? (determinationToApprovalTotal / determinationToApprovalCount) : 0\n    };\n}\n\n// Calculate program performance metrics\nfunction calculateProgramPerformance(data) {\n    if (!data || data.length === 0) {\n        return [];\n    }\n    \n    // Group by program\n    const programGroups = {};\n    \n    data.forEach(record => {\n        const program = record['Program code'] || 'Unknown';\n        \n        if (!programGroups[program]) {\n            programGroups[program] = {\n                program: program,\n                total: 0,\n                approved: 0,\n                denied: 0,\n                pending: 0,\n                avgDays: 0,\n                totalDays: 0,\n                recordsWithDays: 0\n            };\n        }\n        \n        // Increment counts\n        programGroups[program].total++;\n        \n        if (record['Date RTA Approved']) {\n            programGroups[program].approved++;\n        } else if (record['RTA Denial Reason']) {\n            programGroups[program].denied++;\n        } else {\n            programGroups[program].pending++;\n        }\n        \n        // Calculate processing days\n        if (record['Date RTA Received by HACSCM']) {\n            const receiveDate = new Date(record['Date RTA Received by HACSCM']);\n            let endDate;\n            \n            if (record['Date RTA Approved']) {\n                endDate = new Date(record['Date RTA Approved']);\n            } else if (record['RTA Denial Reason'] && record['Date to Fiscal']) {\n                endDate = new Date(record['Date to Fiscal']);\n            }\n            \n            if (receiveDate && endDate) {\n                const days = Math.round((endDate - receiveDate) / (1000 * 60 * 60 * 24));\n                if (days >= 0 && days < 100) {\n                    programGroups[program].totalDays += days;\n                    programGroups[program].recordsWithDays++;\n                }\n            }\n        }\n    });\n    \n    // Calculate averages and sort by total count\n    const result = Object.values(programGroups).map(group => {\n        group.avgDays = group.recordsWithDays > 0 ? (group.totalDays / group.recordsWithDays) : 0;\n        group.approvalRate = group.total > 0 ? ((group.approved / group.total) * 100) : 0;\n        return group;\n    }).sort((a, b) => b.total - a.total);\n    \n    return result;\n}\n\n// Calculate inspector performance metrics\nfunction calculateInspectorPerformance(data) {\n    if (!data || data.length === 0) {\n        return [];\n    }\n    \n    // Group by inspector\n    const inspectorGroups = {};\n    \n    data.forEach(record => {\n        const inspector = record['Inspector'] || 'Unassigned';\n        \n        if (!inspectorGroups[inspector]) {\n            inspectorGroups[inspector] = {\n                inspector: inspector,\n                total: 0,\n                inspected: 0,\n                passed: 0,\n                failed: 0,\n                canceled: 0,\n                avgDaysToInspection: 0,\n                totalDaysToInspection: 0,\n                recordsWithInspectionDays: 0\n            };\n        }\n        \n        // Increment counts\n        inspectorGroups[inspector].total++;\n        \n        if (record['Date Inspected']) {\n            inspectorGroups[inspector].inspected++;\n            \n            const result = record['Initial Inspection Result'];\n            if (result) {\n                const resultLower = result.toLowerCase();\n                if (resultLower.includes('pass')) {\n                    inspectorGroups[inspector].passed++;\n                } else if (resultLower.includes('fail')) {\n                    inspectorGroups[inspector].failed++;\n                } else if (resultLower.includes('cancel')) {\n                    inspectorGroups[inspector].canceled++;\n                }\n            }\n        }\n        \n        // Calculate days to inspection\n        if (record['Date RTA Assigned to Inspector'] && record['Date Inspected']) {\n            const assignDate = new Date(record['Date RTA Assigned to Inspector']);\n            const inspectDate = new Date(record['Date Inspected']);\n            \n            if (assignDate && inspectDate && !isNaN(inspectDate.getTime())) {\n                const days = Math.round((inspectDate - assignDate) / (1000 * 60 * 60 * 24));\n                if (days >= 0 && days < 100) {\n                    inspectorGroups[inspector].totalDaysToInspection += days;\n                    inspectorGroups[inspector].recordsWithInspectionDays++;\n                }\n            }\n        }\n    });\n    \n    // Calculate averages and sort by total count\n    const result = Object.values(inspectorGroups).map(group => {\n        group.avgDaysToInspection = group.recordsWithInspectionDays > 0 ? \n            (group.totalDaysToInspection / group.recordsWithInspectionDays) : 0;\n        \n        group.passRate = group.inspected > 0 ? ((group.passed / group.inspected) * 100) : 0;\n        return group;\n    }).sort((a, b) => b.total - a.total);\n    \n    return result;\n}\n\n// Calculate geographic distribution of applications\nfunction calculateGeographicDistribution(data) {\n    if (!data || data.length === 0) {\n        return [];\n    }\n    \n    // Group by city\n    const cityGroups = {};\n    \n    data.forEach(record => {\n        const city = record['City Code'] || 'Unknown';\n        \n        if (!cityGroups[city]) {\n            cityGroups[city] = {\n                city: city,\n                total: 0,\n                approved: 0,\n                denied: 0,\n                pending: 0,\n                avgRent: 0,\n                totalRent: 0,\n                recordsWithRent: 0\n            };\n        }\n        \n        // Increment counts\n        cityGroups[city].total++;\n        \n        if (record['Date RTA Approved']) {\n            cityGroups[city].approved++;\n        } else if (record['RTA Denial Reason']) {\n            cityGroups[city].denied++;\n        } else {\n            cityGroups[city].pending++;\n        }\n        \n        // Calculate average rent\n        if (record['Proposed Contract Rent']) {\n            const rent = parseFloat(record['Proposed Contract Rent']);\n            if (!isNaN(rent) && rent > 0) {\n                cityGroups[city].totalRent += rent;\n                cityGroups[city].recordsWithRent++;\n            }\n        }\n    });\n    \n    // Calculate averages and sort by total count\n    const result = Object.values(cityGroups).map(group => {\n        group.avgRent = group.recordsWithRent > 0 ? (group.totalRent / group.recordsWithRent) : 0;\n        group.approvalRate = group.total > 0 ? ((group.approved / group.total) * 100) : 0;\n        return group;\n    }).sort((a, b) => b.total - a.total);\n    \n    return result;\n}\n\n// Initialize fallback charts when the regular initialization fails\nfunction initializeFallbackCharts() {\n    console.log('Initializing fallback charts');\n    \n    // Process Timeline Chart\n    if (document.getElementById('processTimelineChart')) {\n        new Chart(document.getElementById('processTimelineChart').getContext('2d'), {\n            type: 'bar',\n            data: {\n                labels: ['Receipt to Assignment', 'Assignment to Inspection', 'Inspection to Rent Determination', 'Determination to Approval/Denial'],\n                datasets: [{\n                    label: 'Average Days',\n                    data: [3, 5, 7, 5],\n                    backgroundColor: '#0d6efd',\n                    borderWidth: 0\n                },\n                {\n                    label: 'Benchmark',\n                    data: [3, 5, 7, 10],\n                    backgroundColor: 'rgba(0,0,0,0)',\n                    borderColor: '#dc3545',\n                    borderWidth: 2,\n                    borderDash: [5, 5],\n                    type: 'line'\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                scales: {\n                    y: {\n                        beginAtZero: true,\n                        title: {\n                            display: true,\n                            text: 'Days'\n                        }\n                    }\n                }\n            }\n        });\n    }\n    \n    // Status Chart\n    if (document.getElementById('statusChart')) {\n        new Chart(document.getElementById('statusChart').getContext('2d'), {\n            type: 'doughnut',\n            data: {\n                labels: ['Approved', 'Denied', 'Pending'],\n                datasets: [{\n                    data: [48, 12, 40],\n                    backgroundColor: ['#198754', '#dc3545', '#ffc107'],\n                    borderWidth: 0\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                cutout: '70%',\n                plugins: {\n                    legend: {\n                        position: 'right',\n                        labels: {\n                            boxWidth: 15,\n                            padding: 15\n                        }\n                    }\n                }\n            }\n        });\n    }\n    \n    // Inspection Chart\n    if (document.getElementById('inspectionChart')) {\n        new Chart(document.getElementById('inspectionChart').getContext('2d'), {\n            type: 'doughnut',\n            data: {\n                labels: ['Pass', 'Fail', 'Canceled', 'Not Inspected'],\n                datasets: [{\n                    data: [45, 15, 5, 35],\n                    backgroundColor: ['#198754', '#dc3545', '#6c757d', '#f8f9fa'],\n                    borderWidth: 0\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                cutout: '70%',\n                plugins: {\n                    legend: {\n                        position: 'right',\n                        labels: {\n                            boxWidth: 15,\n                            padding: 15\n                        }\n                    }\n                }\n            }\n        });\n    }\n    \n    // Program Chart\n    if (document.getElementById('programChart')) {\n        new Chart(document.getElementById('programChart').getContext('2d'), {\n            type: 'bar',\n            data: {\n                labels: ['mtw_ss', 'vou_oth', 'pb_alm', 'pb_colm', 'pb_edge', 'pb_hill'],\n                datasets: [\n                    {\n                        label: 'Approved',\n                        data: [28, 22, 15, 12, 10, 8],\n                        backgroundColor: '#198754'\n                    },\n                    {\n                        label: 'Denied',\n                        data: [5, 4, 3, 3, 2, 2],\n                        backgroundColor: '#dc3545'\n                    },\n                    {\n                        label: 'Pending',\n                        data: [15, 12, 10, 8, 6, 5],\n                        backgroundColor: '#ffc107'\n                    }\n                ]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                scales: {\n                    x: {\n                        stacked: true\n                    },\n                    y: {\n                        stacked: true,\n                        beginAtZero: true\n                    }\n                }\n            }\n        });\n    }\n    \n    // City Chart\n    if (document.getElementById('cityChart')) {\n        new Chart(document.getElementById('cityChart').getContext('2d'), {\n            type: 'bar',\n            data: {\n                labels: ['AT', 'BL', 'BR', 'BU', 'CL', 'DC', 'EG', 'EP', 'FC', 'HL'],\n                datasets: [{\n                    label: 'Applications',\n                    data: [45, 38, 32, 28, 25, 22, 18, 15, 12, 10],\n                    backgroundColor: '#0d6efd',\n                    borderWidth: 0\n                }]\n            },\n            options: {\n                indexAxis: 'y',\n                responsive: true,\n                maintainAspectRatio: false,\n                scales: {\n                    x: {\n                        beginAtZero: true\n                    }\n                },\n                plugins: {\n                    legend: {\n                        display: false\n                    }\n                }\n            }\n        });\n    }\n    \n    // Initialize sparklines for key metrics\n    if (document.getElementById('totalSparkline')) {\n        const data = Array(30).fill(0).map((_, i) => 900 + Math.random() * 300);\n        new Chart(document.getElementById('totalSparkline').getContext('2d'), {\n            type: 'line',\n            data: {\n                labels: Array(30).fill(''),\n                datasets: [{\n                    data: data,\n                    borderColor: '#0d6efd',\n                    borderWidth: 2,\n                    pointRadius: 0,\n                    fill: {\n                        target: 'origin',\n                        above: 'rgba(13, 110, 253, 0.1)'\n                    },\n                    tension: 0.4\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                plugins: {\n                    legend: {\n                        display: false\n                    },\n                    tooltip: {\n                        enabled: false\n                    }\n                },\n                scales: {\n                    x: {\n                        display: false\n                    },\n                    y: {\n                        display: false\n                    }\n                }\n            }\n        });\n    }\n    \n    if (document.getElementById('approvalRateSparkline')) {\n        const data = Array(30).fill(0).map(() => 40 + Math.random() * 20);\n        new Chart(document.getElementById('approvalRateSparkline').getContext('2d'), {\n            type: 'line',\n            data: {\n                labels: Array(30).fill(''),\n                datasets: [{\n                    data: data,\n                    borderColor: '#198754',\n                    borderWidth: 2,\n                    pointRadius: 0,\n                    fill: {\n                        target: 'origin',\n                        above: 'rgba(25, 135, 84, 0.1)'\n                    },\n                    tension: 0.4\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                plugins: {\n                    legend: {\n                        display: false\n                    },\n                    tooltip: {\n                        enabled: false\n                    }\n                },\n                scales: {\n                    x: {\n                        display: false\n                    },\n                    y: {\n                        display: false\n                    }\n                }\n            }\n        });\n    }\n    \n    if (document.getElementById('processingDaysSparkline')) {\n        const data = Array(30).fill(0).map(() => 20 + Math.random() * 10);\n        new Chart(document.getElementById('processingDaysSparkline').getContext('2d'), {\n            type: 'line',\n            data: {\n                labels: Array(30).fill(''),\n                datasets: [{\n                    data: data,\n                    borderColor: '#0dcaf0',\n                    borderWidth: 2,\n                    pointRadius: 0,\n                    fill: {\n                        target: 'origin',\n                        above: 'rgba(13, 202, 240, 0.1)'\n                    },\n                    tension: 0.4\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                plugins: {\n                    legend: {\n                        display: false\n                    },\n                    tooltip: {\n                        enabled: false\n                    }\n                },\n                scales: {\n                    x: {\n                        display: false\n                    },\n                    y: {\n                        display: false\n                    }\n                }\n            }\n        });\n    }\n    \n    if (document.getElementById('pendingSparkline')) {\n        const data = Array(30).fill(0).map(() => 300 + Math.random() * 150);\n        new Chart(document.getElementById('pendingSparkline').getContext('2d'), {\n            type: 'line',\n            data: {\n                labels: Array(30).fill(''),\n                datasets: [{\n                    data: data,\n                    borderColor: '#ffc107',\n                    borderWidth: 2,\n                    pointRadius: 0,\n                    fill: {\n                        target: 'origin',\n                        above: 'rgba(255, 193, 7, 0.1)'\n                    },\n                    tension: 0.4\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                plugins: {\n                    legend: {\n                        display: false\n                    },\n                    tooltip: {\n                        enabled: false\n                    }\n                },\n                scales: {\n                    x: {\n                        display: false\n                    },\n                    y: {\n                        display: false\n                    }\n                }\n            }\n        });\n    }\n}\n\n// Execute fallback chart initialization after page is fully loaded\nwindow.addEventListener('load', function() {\n    // Check if charts have been initialized already\n    setTimeout(function() {\n        try {\n            // If charts haven't been initialized, do it now\n            if (!window.chartsInitialized) {\n                console.log('Charts not yet initialized, running fallback initialization');\n                initializeFallbackCharts();\n                window.chartsInitialized = true;\n            }\n        } catch (e) {\n            console.error('Error initializing charts:', e);\n        }\n    }, 1000);\n});